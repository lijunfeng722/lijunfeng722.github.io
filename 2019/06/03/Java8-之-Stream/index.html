<!DOCTYPE html>
<html lang="en">




<head><meta name="generator" content="Hexo 3.8.0">

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  
      <title>Java8 之 Stream - HeiHeiHei</title>
  

  
  
  <meta name="description" content>
  <meta name="author" content="Li JunFeng">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- load loadjs.js -->
  <script src="/libs/loadjs/dist/loadjs.min.js"></script>

<link rel="stylesheet" href="/libs/animate.css/animate.min.css">
  <!-- load lightgallery -->
<link rel="stylesheet" href="/css/lightgallery.css">
<link rel="stylesheet" href="/libs/noty/lib/noty.css">
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
  






    <link rel="stylesheet" href="/css/taurus.css">
    
        <link rel="stylesheet" href="/css/scheme-taurus/animations.css">
    


<link rel="stylesheet" href="/.css">

  <!-- load font awesome 5 -->
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.2.0/css/all.css" integrity="sha384-hWVjflwFxL6sNzntih27bfxkr27PmbbK/iSvJ+a4+0owXq79v+lsFkW54bOGbiDQ" crossorigin="anonymous">

  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
  </script>
  <!-- load mathjax -->
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax//libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML"></script>

  <!-- load js-cookie -->
  <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
    <script src="/js/social-share.min.js"></script>
    <script src="/js/theme.js"></script>

  <!-- include cookie.js -->
  
  

  <!-- include comment system code -->
  
    <script src="//cdn1.lncld.net/static/js/3.6.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <!-- Favicon
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="/images/favicon.png">
</head>
<body style="display: flex; flex-direction: column; min-height: 100vh;">

 

<header id="header" class="header">
	<div class="header-title">
		
		<div class="header-logo">
			<a href="/">
				<img src="https://avatars2.githubusercontent.com/u/12017992?s=400&u=722ebc8cc275146695a49b651b96e4eb89a182c1&v=4">
			</a>
		</div>
		<div class="header-text">
			<h1>
				<a href="/">HeiHeiHei</a>
			</h1>
			<subtitle>
				
			</subtitle>
		</div>
		
	</div>
	<div id="header-nav">
		



<nav id="nav">
	
	
	
	<div class="nav-item" id="nav-item-toc">
		


<div class="toc-container">
<i class="far fa-times-circle" id="toc-close" onclick="closeTOC(event);" ontouchstart="closeTOC(event);"></i>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流操作"><span class="toc-number">2.</span> <span class="toc-text">流操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中间操作"><span class="toc-number">2.1.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终端操作"><span class="toc-number">2.2.</span> <span class="toc-text">终端操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用流"><span class="toc-number">2.3.</span> <span class="toc-text">使用流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用流-v2"><span class="toc-number">3.</span> <span class="toc-text">使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#筛选"><span class="toc-number">3.1.</span> <span class="toc-text">筛选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找元素"><span class="toc-number">3.2.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归约"><span class="toc-number">3.3.</span> <span class="toc-text">归约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值流"><span class="toc-number">3.4.</span> <span class="toc-text">数值流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建流"><span class="toc-number">3.5.</span> <span class="toc-text">构建流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#收集器"><span class="toc-number">4.</span> <span class="toc-text">收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#收集器简介"><span class="toc-number">4.1.</span> <span class="toc-text">收集器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预定义收集器"><span class="toc-number">4.2.</span> <span class="toc-text">预定义收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义收集器"><span class="toc-number">4.3.</span> <span class="toc-text">自定义收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并行流"><span class="toc-number">5.</span> <span class="toc-text">并行流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意"><span class="toc-number">6.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#流只能遍历一次"><span class="toc-number">6.1.</span> <span class="toc-text">流只能遍历一次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流与集合的区别"><span class="toc-number">6.2.</span> <span class="toc-text">流与集合的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<div class="toc-button" onclick="toggleTOC(event);" ontouchstart="toggleTOC(event);">
    <img src="/images/icons/colorful-outlined/toc.svg" alt>
</div>

	</div>
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="Archives">
			<img src="/images/icons/colorful-outlined/archive.svg" alt>
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon">
		
			<a href="/search/" title="Search">
			<img src="/images/icons/colorful-outlined/search.svg" alt>
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/colorful-outlined/menu.svg" alt>
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/Java/">
						<span>Java</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>
</header>

 

  




  <!-- Primary Page Layout
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div style="flex: 1;">
      <style>
    body {
        background-color: white;
    }
</style>








    
        
            
            
        
    






    
    
        
    

    
        
    









<article class="article" id="/2019/06/03/Java8-之-Stream/" data-name="Java8 之 Stream" data-version>

    <!-- Title -->
    <div class="article-header">
         
         <div class="article-logo">
            <a href="#" data-no-instant>
                <img src="/images/icon/Java.svg" alt onerror="if(this.src != " images uncategorized.svg") this.src="/images/uncategorized.svg" ">
            </a>
         </div>
         
         <h1 class="article-title">
            <a href="/2019/06/03/Java8-之-Stream/">
                Java8 之 Stream
            </a>
        </h1>
        <!-- TODO: support nested categories,display them nicely -->
        
        <ul class="article-categories">
            
            
                <li><a href="/categories/Java/" data-no-instant>
                    <img src="/images/Java.svg" alt="Java" onerror="if(this.src != " images uncategorized.svg") this.src="/images/uncategorized.svg" " title="Java">
                </a></li>
            
        </ul>
        
    </div>
    
    <!-- Date and Author -->
    <div class="article-meta">
    <ul>
            <li><i class="fa fa-calendar"></i> 2019-06-03</li>
            
            <li class="comment-button"><a href="#article-comment"><i class="fa fa-comments"></i> <span id="article-comment-count">0</span></a></li>
            <li><i class="fa fa-eye"></i> <span id="article-visit-count">0</span></li>
            <li class="thumb-up-button" id="thumb-up-button"><i class="far fa-thumbs-up fa-lg" id="thumb-up-icon"></i> <span id="article-thumbup-count">0</span></li>
            
            <li><i class="fa fa-user"></i> Li JunFeng</li>
            <li><i class="fas fa-copyright"></i>
            
                
                
            
            
                <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>
            
            </li>
    </ul>
    
<div class="tags">
	
		
			<label class="tag-1"><a href="/tags/Java8/">Java8</a></label>
		
	
		
			<label class="tag-2"><a href="/tags/Stream/">Stream</a></label>
		
	
	</div>

    </div>
    <div class="article-cards">
        <!-- Author Card -->
        <!---
        <div class='Card-article Card-author'>
            <div class='card-title'>
                <h3></h3>
            </div>
            <div class='card-content'>
                    <div class="author-meta">
                            <div class='author-figure'>
                                <img src="" alt="">
                            </div>
                            <div class='author-name'>
                                Li JunFeng
                            </div>
                        </div>
                        <div class="author-ai">
                            <div class='author-intro'>
                                <!-- TODO: auto generating author description -->
                                <!-- 
                            </div>
                            <div class="author-articles">
                                <!-- TODO: auto generating author articles -->
                                <!-- <ul>
                                    <li>Article 1</li>
                                    <li>Article 2</li>
                                    <li>Article 3</li>
                                    <li>Article 4</li>
                                    <li>Article 5</li>
                                    <li>Article 6</li>
                                </ul>
                            </div>
                        </div>
            </div>
            
        </div> -->

        <!-- Visit Card -->
        <!-- <div class="Card-article Card-visit"> -->
            <!-- <div class="card-title">
  <h3>Post Visit</h3>
</div>
<div class="card-chart">
  <div id="chart-post-visit"></div>
</div> -->
        <!-- </div> -->
        
        <!-- Auto Excerpt Card -->
        <!-- <div class="Card-article Card-excerpt">
            <div class="card-title">
  <h3>Quick Read</h3>
</div>
<div class="card-text">
  <p id="text-post-summary">使用Java8的Stream可以让你的代码：更简洁，更易读；更灵活；可并行

引言
下面两段代码都是用来返回低热量的菜肴名称 ，一个是用Java 7写的，另一个是用Java 8的流 。

Java7：

123456789101112131415161718// List&lt;Dish&gt; menu = ....List&lt;Dish&gt; lowCaloricDishes = new ArrayList&lt;&gt;();// 筛选出低热量的菜肴for(Dish d: menu)    if(d.getCalories() &lt; 400)       ...</p>
</div>
        </div> -->
    </div>
    
    <!-- Gallery -->
    <!-- TODO: add a slider to gallery -->
    

    <!-- Content -->
    <!-- TODO: support table of content -->
    <div class="article-toc" id="article-toc">
    
        


<div class="toc-container">
<i class="far fa-times-circle" id="toc-close" onclick="closeTOC(event);" ontouchstart="closeTOC(event);"></i>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流操作"><span class="toc-number">2.</span> <span class="toc-text">流操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中间操作"><span class="toc-number">2.1.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终端操作"><span class="toc-number">2.2.</span> <span class="toc-text">终端操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用流"><span class="toc-number">2.3.</span> <span class="toc-text">使用流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用流-v2"><span class="toc-number">3.</span> <span class="toc-text">使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#筛选"><span class="toc-number">3.1.</span> <span class="toc-text">筛选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找元素"><span class="toc-number">3.2.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归约"><span class="toc-number">3.3.</span> <span class="toc-text">归约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值流"><span class="toc-number">3.4.</span> <span class="toc-text">数值流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建流"><span class="toc-number">3.5.</span> <span class="toc-text">构建流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#收集器"><span class="toc-number">4.</span> <span class="toc-text">收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#收集器简介"><span class="toc-number">4.1.</span> <span class="toc-text">收集器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预定义收集器"><span class="toc-number">4.2.</span> <span class="toc-text">预定义收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义收集器"><span class="toc-number">4.3.</span> <span class="toc-text">自定义收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并行流"><span class="toc-number">5.</span> <span class="toc-text">并行流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意"><span class="toc-number">6.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#流只能遍历一次"><span class="toc-number">6.1.</span> <span class="toc-text">流只能遍历一次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流与集合的区别"><span class="toc-number">6.2.</span> <span class="toc-text">流与集合的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<div class="toc-button" onclick="toggleTOC(event);" ontouchstart="toggleTOC(event);">
    <img src="/images/icons/colorful-outlined/toc.svg" alt>
</div>

    </div>
    <div class="article-content">
    <p>使用Java8的Stream可以让你的代码：更简洁，更易读；更灵活；可并行</p>
<a id="more"></a>
<h1 id="引言">引言</h1>
<p>下面两段代码都是用来返回低热量的菜肴名称 ，一个是用Java 7写的，另一个是用Java 8的流 。</p>
<ul>
<li>Java7：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;Dish&gt; menu = ....</span></span><br><span class="line">List&lt;Dish&gt; lowCaloricDishes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="comment">// 筛选出低热量的菜肴</span></span><br><span class="line"><span class="keyword">for</span>(Dish d: menu)</span><br><span class="line">    <span class="keyword">if</span>(d.getCalories() &lt; <span class="number">400</span>)</span><br><span class="line">        lowCaloricDishes.add(d);</span><br><span class="line"><span class="comment">// 根据热量对菜肴排序</span></span><br><span class="line">Collections.sort(lowCaloricDishes, <span class="keyword">new</span> Comparator&lt;Dish&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Dish d1, Dish d2)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> Integer.compare(d1.getCalories(), d2.getCalories());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 收集排序好的菜肴的名称</span></span><br><span class="line">List&lt;String&gt; lowCaloricDishesName = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d: lowCaloricDishes)</span><br><span class="line">    lowCaloricDishesName.add(d.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">//在这段代码中，你用了一个“垃圾变量” lowCaloricDishes。它唯一的作用就是作为一次性的中间容器</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Java8：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List&lt;Dish&gt; menu = ....</span></span><br><span class="line">List&lt;String&gt; lowCaloricDishesName =</span><br><span class="line">    menu.stream()<span class="comment">// 从List获取流</span></span><br><span class="line">    .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>) <span class="comment">// 筛选出低热量的菜肴</span></span><br><span class="line">    .sorted(comparing(Dish::getCalories))<span class="comment">// 根据热量对菜肴排序</span></span><br><span class="line">    .map(Dish::getName)<span class="comment">// 将每个Dish映射成String</span></span><br><span class="line">    .collect(toList());<span class="comment">// 收集排序好的菜肴的名称</span></span><br></pre></td></tr></table></figure>
<p>为了利用多核架构并行执行这段代码，你只需要把<code>stream()</code>换成<code>parallelStream()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; lowCaloricDishesName =</span><br><span class="line">    menu.parallelStream()<span class="comment">// 使用并行流</span></span><br><span class="line">    .filter(d -&gt; d.getCalories() &lt; <span class="number">400</span>)</span><br><span class="line">    .sorted(comparing(Dishes::getCalories))</span><br><span class="line">    .map(Dish::getName)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<ul>
<li>代码是以声明性方式写的：说明想要完成什么（筛选热量低的菜肴）而不是说明如何实现（通过if和循环等）。这种方法加上行为参数化让你可以轻松应对变化：你很容易再创建一个代码版本，利用
Lambda表达式来筛选高卡路里的菜肴，而用不着去复制粘贴代码</li>
<li>可以把几个基础操作链接起来，来表达复杂的数据处理流程，同时保持代码清晰可读 。</li>
<li>方便的进行并行处理，无需自己实现多线程代码。</li>
</ul>
<p>外部迭代与内部迭代</p>
<blockquote>
<p>使用Collection接口需要用户去做迭代（比如用for-each），这称为外部迭代。 相反，Streams库使用内部迭代——它帮你把迭代做了，还把得到的流值存在了某个地方，你只要给出一个函数说要干什么就可以了。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用for-each循环外部迭代</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Dish d: menu)&#123;</span><br><span class="line">	names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用背后的迭代器做外部迭代</span></span><br><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = menu.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    Dish d = iterator.next();</span><br><span class="line">    names.add(d.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用流，内部迭代</span></span><br><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">	.map(Dish::getName)</span><br><span class="line">	.collect(toList());</span><br></pre></td></tr></table></figure>
<p>让我们用一个比喻来解释内部迭代的差异和好处吧。比方说你和你两岁的女儿索菲亚说，<u>把玩具收起来</u>：</p>
<p>外部迭代：</p>
<blockquote>
<p>你：“索菲亚，我们把玩具收起来吧。地上还有玩具吗？”
索菲亚：“有，球。”
你：“好，把球放进盒子里。还有吗？”</p>
<p>索菲亚：“有，那是我的娃娃。”
你：“好，把娃娃放进盒子里。还有吗？”
索菲亚：“有，有我的书。”
你：“好，把书放进盒子里。还有吗？”
索菲亚：“没了，没有了。”
你：“好，我们收好啦。”</p>
</blockquote>
<p>这正是你每天都要对Java集合做的。你外部迭代一个集合，显式地取出每个项目再加以处理 。</p>
<p>而使用内部迭代，只需要说你的意图就好了：</p>
<blockquote>
<p>把地上所有的玩具都放进盒子里</p>
</blockquote>
<p>内部迭代比较好的原因有二：
第一，索非亚可以选择一只手拿娃娃，另一只手拿球；第二，她可以决定先拿离盒子最近的那个
东西，然后再拿别的。</p>
<p>同样的道理Streams库的内部迭代可以自动选择一种适合你硬件的数据表示和并行实现。与此相反，一旦通过写for-each而选择了外部迭代，那你基本上就要自己管理所有的并行问题了 。</p>
<h1 id="流操作">流操作</h1>
<p>java.util.stream.Stream中的Stream接口定义了许多操作。它们可以分为两大类。 中间操作与终端操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">    .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)<span class="comment">// 中间操作</span></span><br><span class="line">    .map(Dish::getName)<span class="comment">// 中间操作</span></span><br><span class="line">    .limit(<span class="number">3</span>)<span class="comment">// 中间操作</span></span><br><span class="line">    .collect(toList());<span class="comment">// 终端操作</span></span><br></pre></td></tr></table></figure>
<h2 id="中间操作">中间操作</h2>
<p>诸如filter或sorted等中间操作会返回另一个流。这让多个操作可以连接起来形成一个查询。重要的是，除非流水线上触发一个终端操作，否则中间操作不会执行任何处理 。这是因为中间操作一般都可以合并起来，在终端操作时一次性全部处理 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; menu = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> Dish(<span class="string">"pork"</span>, <span class="keyword">false</span>, <span class="number">800</span>, Dish.Type.MEAT),</span><br><span class="line">            <span class="keyword">new</span> Dish(<span class="string">"beef"</span>, <span class="keyword">false</span>, <span class="number">700</span>, Dish.Type.MEAT),</span><br><span class="line">            <span class="keyword">new</span> Dish(<span class="string">"season fruit"</span>, <span class="keyword">true</span>, <span class="number">120</span>, Dish.Type.OTHER),</span><br><span class="line">            <span class="keyword">new</span> Dish(<span class="string">"chicken"</span>, <span class="keyword">false</span>, <span class="number">400</span>, Dish.Type.MEAT),</span><br><span class="line">            <span class="keyword">new</span> Dish(<span class="string">"french fries"</span>, <span class="keyword">true</span>, <span class="number">530</span>, Dish.Type.OTHER));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = menu.stream()</span><br><span class="line">    .filter(d -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"filtering"</span> + d.getName());</span><br><span class="line">        <span class="keyword">return</span> d.getCalories() &gt; <span class="number">300</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .map(d -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"mapping"</span> + d.getName());</span><br><span class="line">        <span class="keyword">return</span> d.getName();</span><br><span class="line">    &#125;)</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(toList());</span><br><span class="line">System.out.println(names);</span><br></pre></td></tr></table></figure>
<p>打印结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">filtering pork</span><br><span class="line">mapping pork</span><br><span class="line">filtering beef</span><br><span class="line">mapping beef</span><br><span class="line">filtering season fruit</span><br><span class="line">filtering chicken</span><br><span class="line">mapping chicken</span><br><span class="line">[pork, beef, chicken]</span><br></pre></td></tr></table></figure>
<p>你会发现，有好几种优化利用了流的延迟性质。第一，尽管很多菜的热量都高于300卡路里，但只选出了前三个！这是因为limit操作和一种称为<em>短路</em>的技巧，我们会在后文中解释。第二，尽管filter和map是两个独立的操作，但它们合并到同一次遍历中了（我们把这种技术叫作<em>循环合并</em>）。</p>
<h2 id="终端操作">终端操作</h2>
<p>终端操作会从流的流水线生成结果。其结果是任何不是流的值，比如List、 Integer，甚至void。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">menu.stream().forEach(System.out::println);<span class="comment">// forEach是一个返回void的终端操作</span></span><br><span class="line">menu.stream().collect(toList()); <span class="comment">// 返回List</span></span><br><span class="line">menu.stream().collect(toMap(Dish::getName, Function.identity()));<span class="comment">// 返回Map</span></span><br></pre></td></tr></table></figure>
<h2 id="使用流">使用流</h2>
<p>总而言之，流的使用一般包括三件事：</p>
<ol>
<li>一个数据源（如集合）来执行一个查询；</li>
<li>一个中间操作链，形成一条流的流水线；</li>
<li>一个终端操作，执行流水线，并能生成结果。</li>
</ol>
<p>详细的中间操作和终端操作请参见API文档。</p>
<h1 id="使用流-v2">使用流</h1>
<p>Stream API支持的许多操作。这些操作能让你快速完成复杂的数据查询，如筛选、切片、映射、查找、匹配和归约。</p>
<p>最后，我们会看看一些特殊的流：数值流、来自文件和数组等多种来源的流，最后是无限流 。</p>
<h2 id="筛选">筛选</h2>
<dl>
<dt>filter(Predicate&lt;T&gt;)</dt>
<dd>接受一个谓词（一个返回boolean的函数）作为参数，并返回一个包括所有符合谓词的元素的流。</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出所有素菜，创建一张素食菜单</span></span><br><span class="line">List&lt;Dish&gt; vegetarianMenu = menu.stream()</span><br><span class="line">    .filter(Dish::isVegetarian)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<dl>
<dt>distinct()</dt>
<dd>它会返回一个元素各异（根据流所成元素的hashCode和equals方法实现）的流</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 筛选出列表中所有的偶数，并确保没有重复</span></span><br><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">numbers.stream()</span><br><span class="line">    .filter(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    .distinct()</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<dl>
<dt>limit(int)</dt>
<dd>该方法会返回一个不超过给定长度的流。所需的长度作为参数传递给limit。如果流是有序的，则最多会返回前n个元素。</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选出热量超过300卡路里的头三道菜</span></span><br><span class="line">List&lt;Dish&gt; dishes = menu.stream()</span><br><span class="line">    .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">    .limit(<span class="number">3</span>)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>请注意limit也可以用在无序流上，比如源是一个Set。这种情况下， limit的结果不会以任何顺序排列。</p>
<dl>
<dt>skip(n)</dt>
<dd>返回一个扔掉了前n个元素的流。如果流中元素不足n个，则返回一个空流。</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跳过超过300卡路里的头两道菜，并返回剩下的</span></span><br><span class="line">List&lt;Dish&gt; dishes = menu.stream()</span><br><span class="line">    .filter(d -&gt; d.getCalories() &gt; <span class="number">300</span>)</span><br><span class="line">    .skip(<span class="number">2</span>)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>映射</p>
<blockquote>
<p>一个非常常见的数据处理套路就是从某些对象中选择信息。比如在SQL里，你可以从表中选择一列。 Stream API也通过map和flatMap方法提供了类似的工具。</p>
</blockquote>
<dl>
<dt>map (Function&lt;T,R&gt;)</dt>
<dd>接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法引用Dish::getName传给了map方法，来提取流中菜肴的名称</span></span><br><span class="line">List&lt;String&gt; dishNames = menu.stream()</span><br><span class="line">    .map(Dish::getName)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>因为getName方法返回一个String，所以map方法输出的流的类型就是Stream<string>。</string></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//提取每个菜肴名称的长度</span></span><br><span class="line">List&lt;Integer&gt; dishNameLengths = menu.stream()</span><br><span class="line">    .map(Dish::getName)</span><br><span class="line">    .map(String::length)</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>第一个map将Stream&lt;Dish&gt;映射为Stream&lt;String&gt;，然后第二个map又将Stream&lt;String&gt;映射为Stream&lt;Integer&gt;，在IDEA中可以看到给出的提示，如下图：</p>
<p><img src="/2019/06/03/Java8-之-Stream/map.png" alt="idea对Stream的提示"></p>
<dl>
<dt>flatMap(Function&lt;T,R&gt;)</dt>
<dd>将函数返回的Stream&lt;T&gt;并不是分别映射成一个流(导致最终映射的结果是Stream&lt;Stream&lt;T&gt;&gt;)，而是映射成流的内容（最终映射结果为Stream&lt;T&gt;）。</dd>
</dl>
<p>对于一张单表，如何返回一张列表，列出里面各不相同的字符呢？</p>
<p>例如，给定单词列表<code>[&quot;Hello&quot;, &quot;World&quot;]</code>，你想要返回列表<code>[&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;o&quot;,&quot;W&quot;,&quot;r&quot;,&quot;d&quot;]</code>。</p>
<p>你可能会认为这很容易，你可以把每个单词映射成一张字符表，然后调用distinct来过滤重复的字符。第一个版本可能是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; words = Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"World"</span>);</span><br><span class="line">words.stream()</span><br><span class="line">    .map(word -&gt; word.split(<span class="string">""</span>))</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>传递给map方法的Lambda为每个单词返回了一个String[]。因此，map返回的流实际上是Stream&lt;String[]&gt;类型的。你真正想要的是用Stream&lt;String&gt;来表示一个字符流。</p>
<p><img src="/2019/06/03/Java8-之-Stream/flatMap.png" alt="不正确的使用map1"></p>
<p>首先，你需要一个字符流，而不是数组流。有一个叫作Arrays.stream()的方法可以接受一个数组并产生一个流 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words.stream()</span><br><span class="line">    .map(word -&gt; word.split(<span class="string">""</span>))<span class="comment">// 每个单词转换为由其字母构成的数组</span></span><br><span class="line">    .map(Arrays::stream)<span class="comment">// 让每个数组变成一个单独的流</span></span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>当前的解决方案仍然搞不定！ 这是因为，你现在得到的是 Stream&lt;Stream&lt;String&gt;&gt;。</p>
<p>现在flatMap终于派上用场了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters = words.stream()</span><br><span class="line">    .map(w -&gt; w.split(<span class="string">""</span>))</span><br><span class="line">    .flatMap(Arrays::stream)</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/03/Java8-之-Stream/%E4%BD%BF%E7%94%A8flatMap%E6%89%BE%E5%87%BA%E5%8D%95%E8%AF%8D%E5%88%97%E8%A1%A8%E4%B8%AD%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C%E7%9A%84%E5%AD%97%E7%AC%A6.PNG" alt="使用flatMap找出单词列表中各不相同的字符"></p>
<p>上面的代码也可以直接写成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; uniqueCharacters = words.stream()</span><br><span class="line">    .flatMap(w -&gt; Arrays.stream(w.split(<span class="string">""</span>)))</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(toList());</span><br></pre></td></tr></table></figure>
<p>查找和匹配</p>
<p>数据集中的某些元素是否匹配一个给定的属性。 Stream通过allMatch、 anyMatch、 noneMatch、 findFirst和findAny方法提供了这样的工具 。</p>
<dl>
<dt>anyMatch(Predicate&lt;T&gt;)</dt>
<dd>检查谓词是否至少匹配一个元素</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> hasVegetarian = menu.stream().anyMatch(Dish::isVegetarian);</span><br></pre></td></tr></table></figure>
<dl>
<dt>allMatch(Predicate&lt;T&gt;)</dt>
<dd>检查谓词是否匹配所有元素</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isHealthy = menu.stream().allMatch(d -&gt; d.getCalories() &lt; <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<dl>
<dt>noneMatch(Predicate&lt;T&gt;)</dt>
<dd>没有任何元素与给定的谓词匹配</dd>
</dl>
<h2 id="查找元素">查找元素</h2>
<dl>
<dt>findAny(Predicate&lt;T&gt;)</dt>
<dd>将返回当前流中的任意元素</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Dish&gt; dish = menu.stream()</span><br><span class="line">    .filter(Dish::isVegetarian)</span><br><span class="line">    .findAny();</span><br></pre></td></tr></table></figure>
<p>流水线将在后台进行优化使其只需走一遍，并在利用短路找到结果时立即结束。</p>
<p>Optional 是什么？</p>
<blockquote>
<p>Optional&lt;T&gt;类（java.util.Optional）是一个容器类，代表一个值存在或不存在。在上面的代码中， findAny可能什么元素都没找到。 Java 8的库设计人员引入了Optional&lt;T&gt;，这样就不用返回众所周知容易出问题的null了。</p>
</blockquote>
<p>我们在这里不会详细讨论Optional，以后的文章中会进行介绍。这里只给出几个常见的API。</p>
<ul>
<li>isPresent()将在Optional包含值的时候返回true, 否则返回false。</li>
<li>ifPresent(Consumer&lt;T&gt; block)会在值存在的时候执行给定的代码块。</li>
<li>T get()会在值存在时返回值，否则抛出一个NoSuchElement异常。</li>
<li>T orElse(T other)会在值存在时返回值，否则返回一个默认值</li>
</ul>
<p>例如，在前面的代码中你需要显式地检查Optional对象中是否存在一道菜可以访问其名称：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu.stream()</span><br><span class="line">    .filter(Dish::isVegetarian)</span><br><span class="line">    .findAny()<span class="comment">// 返回一个Optional&lt;Dish&gt;</span></span><br><span class="line">    .ifPresent(d -&gt; System.out.println(d.getName());<span class="comment">// 如果包含一个值就打印它，否则什么都不做</span></span><br></pre></td></tr></table></figure>
<dl>
<dt>findFirst (Predicate&lt;T&gt;)</dt>
<dd>有些流有一个出现顺序（encounter order）来指定流中项目出现的逻辑顺序（比如由List或排序好的数据列生成的流）。对于这种流，你可能想要找到第一个元素。</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; someNumbers = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Optional&lt;Integer&gt; firstSquareDivisibleByThree = someNumbers.stream()</span><br><span class="line">    .map(x -&gt; x * x)</span><br><span class="line">    .filter(x -&gt; x % <span class="number">3</span> == <span class="number">0</span>)</span><br><span class="line">    .findFirst(); <span class="comment">// 9</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>何时使用findFirst和findAny你可能会想，为什么会同时有findFirst和findAny呢？答案是并行。找到第一个元素在并行上限制更多。如果你不关心返回的元素是哪个，请使用findAny，因为它在使用并行流时限制较少。</p>
</blockquote>
<h2 id="归约">归约</h2>
<dl>
<dt>reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</dt>
<dd>在流上进行规约操作，接收一个初始值T，和一个BinaryOperator。后者将两个元素结合起来产生一个新值 。</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有元素的和</span></span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"><span class="comment">// 所有元素的积</span></span><br><span class="line"><span class="keyword">int</span> product = numbers.stream().reduce(<span class="number">1</span>, (a, b) -&gt; a * b);</span><br><span class="line"><span class="comment">// 使用方法引用</span></span><br><span class="line"><span class="keyword">int</span> sum = numbers.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 使用无初试值的版本，当流中没有值时，Optional中为null</span></span><br><span class="line">Optional&lt;Integer&gt; sum = numbers.stream().reduce((a, b) -&gt; (a + b));</span><br></pre></td></tr></table></figure>
<p>求最大值和最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Integer&gt; max = numbers.stream().reduce(Integer::max);</span><br><span class="line">Optional&lt;Integer&gt; min = numbers.stream().reduce(Integer::min);</span><br></pre></td></tr></table></figure>
<h2 id="数值流">数值流</h2>
<h3 id="原始类型流特化">原始类型流特化</h3>
<p>我们在前面看到了可以使用reduce方法计算流中元素的总和。例如，你可以像下面这样计算菜单的热量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">	.map(Dish::getCalories)</span><br><span class="line">	.reduce(<span class="number">0</span>, Integer::sum);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">	.map(Dish::getCalories)</span><br><span class="line">	.sum();</span><br></pre></td></tr></table></figure>
<p>但这是不可能的。问题在于map方法会生成一个Stream&lt;T&gt;。虽然流中的元素是Integer类型，但Stream没有定义sum方法。</p>
<p>这段代码的问题是，它有一个暗含的装箱成本。每个Integer都必须拆箱成一个原始类型，再进行求和。要是可以直接像下面这样调用sum方法，岂不是更好？</p>
<p>Java 8引入了三个原始类型特化流接口来解决这个问题： IntStream、 DoubleStream和LongStream，分别将流中的元素特化为int、 long和double，从而避免了暗含的装箱成本。每个接口都带来了进行常用数值归约的新方法，比如sum、max。此外还有在必要时再把它们转换回对象流的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 映射到数值流</span></span><br><span class="line"><span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">	.mapToInt(Dish::getCalories)</span><br><span class="line">	.sum();</span><br></pre></td></tr></table></figure>
<p>一旦有了数值流，你可能会想把它转换回非特化流。例如，IntStream上的操作只能产生原始整数： IntStream 的 map操作接受的Lambda必须接受int并返回int。但是你可能想要生成另一类值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IntStream intStream = menu.stream().mapToInt(Dish::getCalories);</span><br><span class="line">Stream&lt;Integer&gt; stream = intStream.boxed();</span><br></pre></td></tr></table></figure>
<h3 id="数值范围">数值范围</h3>
<p>假设你想要生成1和100之间的所 有数字。</p>
<p>Java 8引入了IntStream和LongStream，帮助生成这种范围。他们都有两个方法range和rangeClosed。这两个方法都是第一个参数接受起始值，第二个参数接受结束值。但range是不包含结束值的，而rangeClosed则包含结束值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成[1,100]之间的偶数</span></span><br><span class="line">IntStream evenNumbers = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).filter(n -&gt; n % <span class="number">2</span> == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="构建流">构建流</h2>
<h3 id="由值创建流">由值创建流</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.of创建流</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Java 8 "</span>, <span class="string">"Lambdas "</span>, <span class="string">"In "</span>, <span class="string">"Action"</span>);</span><br><span class="line">stream.map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line"><span class="comment">// empty()得到一个空流</span></span><br><span class="line">Stream&lt;String&gt; emptyStream = Stream.empty();</span><br></pre></td></tr></table></figure>
<h3 id="由数组创建流">由数组创建流</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Arrays.stream从数组创建一个流</span></span><br><span class="line"><span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> sum = Arrays.stream(numbers).sum();</span><br></pre></td></tr></table></figure>
<h3 id="由文件生成流">由文件生成流</h3>
<p>Java中用于处理文件等I/O操作的NIO API（非阻塞 I/O）已更新，以便利用Stream API。java.nio.file.Files中的很多静态方法都会返回一个流。例如，一个很有用的方法是Files.lines，它会返回一个由指定文件中的各行构成的字符串流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 统计一个文件中有多少各不相同的词</span></span><br><span class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span>(Stream&lt;String&gt; lines = </span><br><span class="line">    Files.lines(Paths.get(<span class="string">"data.txt"</span>), Charset.defaultCharset()))&#123;</span><br><span class="line">        uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">" "</span>)))</span><br><span class="line">            .distinct()</span><br><span class="line">            .count();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="由函数生成流：创建无限流">由函数生成流：创建无限流</h3>
<ul>
<li>迭代</li>
</ul>
<p>iterate方法接受一个初始值，还有一个依次应用在每个产生的新值上的Lambda</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">2</span>)</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>请注意，iterate将生成一个无限流——这个流没有结尾，因为值是按需计算的，可以永远计算下去。我们说这个流是无界的。正如我们前面所讨论的，这是流和集合之间的一个关键区别。我们使用limit方法来显式限制流的大小。</p>
<p>一般来说，在需要依次生成一系列值的时候应该使用iterate 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;,</span><br><span class="line">               t -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;t[<span class="number">1</span>],t[<span class="number">0</span>] + t[<span class="number">1</span>]&#125;)</span><br><span class="line">    .limit(<span class="number">10</span>)</span><br><span class="line">    .map(t -&gt; t[<span class="number">0</span>])</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">//这段代码将打印斐波纳契数列： 0, 1, 1, 2, 3, 5, 8, 13, 21, 34…</span></span><br></pre></td></tr></table></figure>
<ul>
<li>生成</li>
</ul>
<p>与iterate方法类似， generate方法也可让你按需生成一个无限流。但generate不是依次对每个新生成的值应用函数的。它接受一个Supplie&lt;T&gt;类型的Lambda提供新的值 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Stream.generate(Math::random)</span><br><span class="line">    .limit(<span class="number">5</span>)</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">0.9410810294106129</span></span><br><span class="line"><span class="comment">0.6586270755634592</span></span><br><span class="line"><span class="comment">0.9592859117266873</span></span><br><span class="line"><span class="comment">0.13743396659487006</span></span><br><span class="line"><span class="comment">0.3942776037651241</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>我们使用的供应源（指向Math.random的方法引用）是无状态的：它不会在任何地方记录任何值。但供应源不一定是无状态的。你可以创建存储状态的供应源，它可以修改状态，并在为流生成下一个值时使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">IntSupplier fib = <span class="keyword">new</span> IntSupplier()&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldPrevious = <span class="keyword">this</span>.previous;</span><br><span class="line">        <span class="keyword">int</span> nextValue = <span class="keyword">this</span>.previous + <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.previous = <span class="keyword">this</span>.current;</span><br><span class="line">        <span class="keyword">this</span>.current = nextValue;</span><br><span class="line">        <span class="keyword">return</span> oldPrevious;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">IntStream.generate(fib).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h1 id="收集器">收集器</h1>
<p>你有一个由Transaction构成的List，并且想按照名义货币进行分组。在没有Lambda的Java里，哪怕像这种简单的用例实现起来都很啰嗦，就像下面这样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立累积交易分组的Map</span></span><br><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Transaction transaction : transactions) &#123;</span><br><span class="line">    <span class="comment">// 提取Transaction的货币</span></span><br><span class="line">    Currency currency = transaction.getCurrency();</span><br><span class="line">    List&lt;Transaction&gt; transactionsForCurrency = transactionsByCurrencies.get(currency);</span><br><span class="line">    <span class="keyword">if</span> (transactionsForCurrency == <span class="keyword">null</span>) &#123; <span class="comment">//如果分组Map中没有这种货币的条目，就创建一个</span></span><br><span class="line">        transactionsForCurrency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        transactionsByCurrencies.put(currency, transactionsForCurrency);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前遍历的Transaction加入同一货币的Transaction的List</span></span><br><span class="line">    transactionsForCurrency.add(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽管代码的目的很简单——把列表中的交易按货币分组——但是写起来却很麻烦。更糟糕的是，读起来比写起来更费劲！</p>
<p>而用Stream中collect方法，你就可以用一句话实现 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Currency, List&lt;Transaction&gt;&gt; transactionsByCurrencies =</span><br><span class="line">	transactions.stream().collect(groupingBy(Transaction::getCurrency));</span><br></pre></td></tr></table></figure>
<h2 id="收集器简介">收集器简介</h2>
<p>传递给collect()的参数是Collector接口的一个实现 。刚才是通过groupingBy方法获得了一个收集器的实现。我们之前也见过collect(Collectos.toList())的用法，所以显然Collectos.toList()也是返回了Collector接口的一种实现。</p>
<p>我们先看一些JDK预定义的收集器，它们就可以处理大部分实际情况。</p>
<h2 id="预定义收集器">预定义收集器</h2>
<h3 id="分组">分组</h3>
<dl>
<dt>Collectors.groupingBy(Function&lt;T,K&gt;)</dt>
<dd>接收一个分类函数，返回一个收集器。该收集器能根据分组函数对流中的元素进行分组，收集到一个Map&lt;K,List&lt;T&gt;&gt;。</dd>
</dl>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, List&lt;Dish&gt;&gt; dishesByType =</span><br><span class="line">	menu.stream().collect(groupingBy(Dish::getType));</span><br><span class="line">System.out.println(dishesByType);</span><br><span class="line"><span class="comment">// &#123;OTHER=[season fruit, french fries, rice, pizza], MEAT=[pork, beef, chicken], FISH=[prawns, salmon]&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，分类函数是提取每个DIsh的Type。分类函数还可以做的更复杂，而不仅是属性提取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CaloricLevel &#123; DIET, NORMAL, FAT &#125;</span><br><span class="line">Map&lt;CaloricLevel, List&lt;Dish&gt;&gt; dishesByCaloricLevel = menu.stream()</span><br><span class="line">    .collect(</span><br><span class="line">        groupingBy(dish -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span></span><br><span class="line">                CaloricLevel.NORMAL;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>上面的分类函数根据热量进行分组。可以看到，因为分类函数返回的是CaloricLevel类型，所以最终的Map的键的类型就是CaloricLevel。</p>
<h4 id="多级分组">多级分组</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Map&lt;CaloricLevel, List&lt;Dish&gt;&gt;&gt; dishesByTypeCaloricLevel =</span><br><span class="line">    menu.stream().collect(</span><br><span class="line">        groupingBy(Dish::getType,</span><br><span class="line">                   groupingBy(dish -&gt; &#123;</span><br><span class="line">                       <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">                       <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT;</span><br><span class="line">                   &#125;)</span><br><span class="line">                  )</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line">        System.out.println(dishesByTypeCaloricLevel);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">OTHER=&#123;DIET=[season fruit, rice], NORMAL=[french fries, pizza]&#125;, </span></span><br><span class="line"><span class="comment">MEAT=&#123;DIET=[chicken], FAT=[pork], NORMAL=[beef]&#125;, </span></span><br><span class="line"><span class="comment">FISH=&#123;DIET=[prawns], NORMAL=[salmon]&#125;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="按子组收集数据">按子组收集数据</h4>
<p>观察一下，在多级分组中，外层的groupingBy方法接收了两个参数，第一个参数是外层分类函数，第二个参数实际上是一个Collector。所以第二个参数实际可以传入任意的收集器而不一定是groupingBy()返回的收集器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别统计每种菜肴的个数</span></span><br><span class="line">Map&lt;Dish.Type, Long&gt; typesCount = menu.stream()</span><br><span class="line">    .collect(  groupingBy(Dish::getType, counting())  );</span><br><span class="line"><span class="comment">// &#123;MEAT=3, FISH=2, OTHER=4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别统计每种菜肴的卡路里总数</span></span><br><span class="line">Map&lt;Dish.Type, Integer&gt; totalCaloriesByType =menu.stream()</span><br><span class="line">    .collect(   groupingBy(Dish::getType, summingInt(Dish::getCalories))    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分别统计每种菜肴中，卡路里最高的菜肴</span></span><br><span class="line">Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt; mostCaloricByType = menu.stream()</span><br><span class="line">.collect(</span><br><span class="line">    groupingBy(Dish::getType,</span><br><span class="line">               maxBy(comparingInt(Dish::getCalories)))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &#123;FISH=Optional[salmon], OTHER=Optional[pizza], MEAT=Optional[pork]&#125;</span></span><br></pre></td></tr></table></figure>
<p><u>实际上，普通的单参数groupingBy(f)（其中f是分类函数）是groupingBy(f, toList())的简便写法 。</u></p>
<ul>
<li>把收集器的结果转换为另一种类型 :</li>
</ul>
<p>注意到上面的例子中，分组后取卡路里最高的菜肴。最后的结果是<code>Map&lt;Dish.Type, Optional&lt;Dish&gt;&gt;</code>，Map的value是<code>Option&lt;Dish&gt;</code>类型的，你可能想把它转换成Dish类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Dish&gt; mostCaloricByType = menu.stream()</span><br><span class="line">    .collect(</span><br><span class="line">        groupingBy(Dish::getType,</span><br><span class="line">                   collectingAndThen(</span><br><span class="line">                       maxBy(comparingInt(Dish::getCalories)),</span><br><span class="line">                       Optional::get)</span><br><span class="line">                  )</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// &#123;FISH=salmon, OTHER=pizza, MEAT=pork&#125;</span></span><br></pre></td></tr></table></figure>
<dl>
<dt>Collectors.collectingAndThen()</dt>
<dd>这个工厂方法接受两个参数——要转换的收集器以及转换函数，并返回另一个新收集器。新收集器相当于旧收集器的一个包装，使得collect操作的最后一步就是将返回值用转换函数做一个映射。</dd>
</dl>
<p>上面的例子中，被包起来的收集器就是用maxBy建立的那个，而转换函数Optional::get则把返回的Optional中的值提取出来。</p>
<ul>
<li>与groupingBy联合使用的其他收集器的例子 :</li>
</ul>
<p>之前讲过，groupingBy方法的第二个参数可以是任意的收集器。再举个复杂点的例子。我们希望将菜单分组，然后分别统计每个组中都有那些CaloricLevel 。就是说，我们希望的得到如下的分组结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;OTHER=[DIET, NORMAL], MEAT=[DIET, NORMAL, FAT], FISH=[DIET, NORMAL]&#125;</span><br></pre></td></tr></table></figure>
<p>这样，如果你想吃鱼并且在减肥，那很容易找到一道菜 。</p>
<p>看下代码是如何实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream()</span><br><span class="line">    .collect(</span><br><span class="line">        groupingBy(Dish::getType, </span><br><span class="line">                   mapping(<span class="keyword">this</span>::judgeCaloricLevel, toSet())</span><br><span class="line">                  )</span><br><span class="line">	);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> CaloricLevel <span class="title">judgeCaloricLevel</span><span class="params">(<span class="keyword">int</span> calories)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">400</span>) <span class="keyword">return</span> CaloricLevel.DIET;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (dish.getCalories() &lt;= <span class="number">700</span>) <span class="keyword">return</span> CaloricLevel.NORMAL;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> CaloricLevel.FAT; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传递给mapping方法的转换函数将Dish映射成了CaloricLevel：生成的CaloricLevel流传递给一个toSet收集器，它和toList类似，不过是把流中的元素累积到Set而不是List中，以便仅保留不相同的值。</p>
<p>请注意在上示例中，对于返回的Set是什么类型并没有任何保证。但通过使用toCollection，你就可
以有更多的控制。例如，你可以给它传递一个构造函数引用来要求HashSet：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Dish.Type, Set&lt;CaloricLevel&gt;&gt; caloricLevelsByType = menu.stream()</span><br><span class="line">    .collect(</span><br><span class="line">        groupingBy(Dish::getType, </span><br><span class="line">                   mapping(<span class="keyword">this</span>::judgeCaloricLevel, toCollection(HashSet::<span class="keyword">new</span>))</span><br><span class="line">                  )</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<h3 id="分区">分区</h3>
<p>分区是分组的特殊情况：由一个谓词（返回一个布尔值的函数）作为分类函数，它称分区函数。分区函数返回一个布尔值，这意味着得到的分组Map的键类型是Boolean，于是它最多可以分为两组——true是一组， false是一组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把菜单按照素食和非素食分开</span></span><br><span class="line">Map&lt;Boolean, List&lt;Dish&gt;&gt; partitionedMenu =</span><br><span class="line">	menu.stream().collect(partitioningBy(Dish::isVegetarian));</span><br><span class="line"><span class="comment">// &#123;false=[pork, beef, chicken, prawns, salmon],true=[french fries, rice, season fruit, pizza]&#125;</span></span><br><span class="line"><span class="comment">// 那么通过Map中键为true的值，就可以找出所有的素食菜肴了：</span></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = partitionedMenu.get(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 请注意，用同样的分区谓词，对菜单流作筛选，也可以获得相同的结果：</span></span><br><span class="line">List&lt;Dish&gt; vegetarianDishes = menu.stream().filter(Dish::isVegetarian).collect(toList());</span><br></pre></td></tr></table></figure>
<h2 id="自定义收集器">自定义收集器</h2>
<p>我们已经看过JDK中预定义了Collector接口的许多收集器实现，例如通过工厂方法Collectors.toList()或Collectors.groupingBy()获得的预定义收集器。另外，我们也可以为Collector接口提供自己的实现。</p>
<p>而在学习自定义收集器前，我们先看下collect方法的其他使用方式。</p>
<p>在之前的代码中，比如<code>menu.stream().filter(Dish::isVegetarian).collect(toList());</code>，我们直接向collect方法传递了一个收集器，然后collect方法就可以拿着这个收集器进行收集工作了。在这里，collect方法拿着toList()提供的收集器，将上游流中的每个元素收集到一个List中。</p>
<p>然而，collect方法还有其它重写版本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianDishs = </span><br><span class="line">    menu.stream()</span><br><span class="line">        .filter(Dish::isVegetarian)</span><br><span class="line">        .collect(ArrayList::<span class="keyword">new</span>,</span><br><span class="line">                (list, dish) -&gt; list.add(dish),</span><br><span class="line">                (list1, list2) -&gt; list1.addAll(list2));</span><br></pre></td></tr></table></figure>
<p>看下collect该重写版本的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">              BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">              BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>supplier : 该函数定义如何获得一个用于保存最终元素的容器。</li>
<li>accumulator：该函数定义如何将流中的元素追加到结果容器</li>
<li>combiner: 该函数定义如何将两个部分结果容器，合并为一个结果容器</li>
<li>collect函数最终返回一个结果容器。</li>
</ul>
<p>在使用串行流的情况下，该collect方法执行的步骤类似于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R result = supplier.get();<span class="comment">// 从supplier函数获得一个用于保存最终元素的容器。</span></span><br><span class="line"><span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">	accumulator.accept(result, element);<span class="comment">// accumulator函数式接口中会将元素追加到结果容器</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>
<p>注意到上面只调用了一次supplier函数，并且没有使用到combiner，这是应为如果在串行流中收集，只会生成一个结果容器。但是如果使用并行流时，会调用多次supplier来获得多个部分结果容器，然后combiner函数会将这些部分结果容器最终组合到一起。</p>
<p>可以通过例子来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianDishes =</span><br><span class="line">                menu.parallelStream()</span><br><span class="line">                    .filter(Dish::isVegetarian)</span><br><span class="line">                    .collect(() -&gt; &#123;</span><br><span class="line">                                 <span class="keyword">synchronized</span> (CollectorTest.class) &#123;</span><br><span class="line">                                     System.out.println(<span class="string">"create new list"</span>);</span><br><span class="line">                                     <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;<span class="comment">/*supplier*/</span>,</span><br><span class="line">                             (list, dish) -&gt; &#123;</span><br><span class="line">                                 <span class="keyword">synchronized</span> (CollectorTest.class) &#123;</span><br><span class="line">                                     System.out.println(<span class="string">"add dish: "</span> + dish);</span><br><span class="line">                                     list.add(dish);</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;<span class="comment">/*accumulator*/</span>,</span><br><span class="line">                             (list1, list2) -&gt; &#123;</span><br><span class="line">                                 <span class="keyword">synchronized</span> (CollectorTest.class) &#123;</span><br><span class="line">                                     System.out.println(<span class="string">"combine list"</span>);</span><br><span class="line">                                     System.out.println(<span class="string">"list1: "</span> + list1);</span><br><span class="line">                                     System.out.println(<span class="string">"list2: "</span> + list2);</span><br><span class="line">                                     list1.addAll(list2);</span><br><span class="line">                                     System.out.println(<span class="string">"after combine: "</span> + list1);</span><br><span class="line">                                 &#125;</span><br><span class="line">                             &#125;<span class="comment">/*combiner*/</span>);</span><br><span class="line"><span class="comment">/*加上synchronized是为了防止多线程会并发调用supplier、accumulator、combiner，打印的时候发生混乱。</span></span><br><span class="line"><span class="comment">控制台输出如下（倒着看更容易观察清楚。。）：</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">add dish: rice</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">add dish: season fruit</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: []</span></span><br><span class="line"><span class="comment">list2: []</span></span><br><span class="line"><span class="comment">after combine: []</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">add dish: pizza</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">create new list</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: []</span></span><br><span class="line"><span class="comment">list2: []</span></span><br><span class="line"><span class="comment">after combine: []</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: [season fruit]</span></span><br><span class="line"><span class="comment">list2: []</span></span><br><span class="line"><span class="comment">after combine: [season fruit]</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: []</span></span><br><span class="line"><span class="comment">list2: [season fruit]</span></span><br><span class="line"><span class="comment">after combine: [season fruit]</span></span><br><span class="line"><span class="comment">add dish: french fries</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: [pizza]</span></span><br><span class="line"><span class="comment">list2: []</span></span><br><span class="line"><span class="comment">after combine: [pizza]</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: [french fries]</span></span><br><span class="line"><span class="comment">list2: [rice]</span></span><br><span class="line"><span class="comment">after combine: [french fries, rice]</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: [french fries, rice]</span></span><br><span class="line"><span class="comment">list2: [pizza]</span></span><br><span class="line"><span class="comment">after combine: [french fries, rice, pizza]</span></span><br><span class="line"><span class="comment">combine list</span></span><br><span class="line"><span class="comment">list1: [season fruit]</span></span><br><span class="line"><span class="comment">list2: [french fries, rice, pizza]</span></span><br><span class="line"><span class="comment">after combine: [season fruit, french fries, rice, pizza]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>可以看到，创建了不只两个中间结果容器，然后最终他们都被合并到一个结果容器中。至于到底会创建几个中间结果容器(即同时创建的子任务个数)，与子任务的大小和CPU核心线程数有关。具体内容可参考《Java8实战》关于Spliterator和ForkJoinPool相关部分。</p>
<h3 id="理解-collector-接口声明的方法">理解 Collector 接口声明的方法</h3>
<p>理解了上面的内容，在来看Collector就容易的多了。</p>
<p>之前说过，toList()返回了一个预定义的收集器实现，当我们调用<code>stream.collect(toList())</code>时，collect方法会使用该收集器，将流中的所有元素收集成一个List。我们通过研究这个收集器是怎么实现的，可以很好地了解：</p>
<ol>
<li>Collector接口是怎么定义的</li>
<li>收集器被传入到collect()方法后，是如何被使用的。</li>
</ol>
<p>先看下Collector接口的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    T是流中要收集的项目的泛型。</span></span><br><span class="line"><span class="comment">    A是累加器本身的类型。累加器在收集过程中用于累积部分结果。</span></span><br><span class="line"><span class="comment">    R是收集操作得到的对象的类型。（通常但并不一定是集合）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">A</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如，你可以实现一个ToListCollector&lt;T&gt;类，将Stream&lt;T&gt;中的所有元素收集到一个List&lt;T&gt;里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">List</span>&lt;<span class="title">T</span>&gt;, <span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; </span></span><br><span class="line"><span class="class">// <span class="title">T</span> 对应 <span class="title">T</span></span></span><br><span class="line"><span class="class">// <span class="title">List</span>&lt;<span class="title">T</span>&gt; 对应<span class="title">A</span></span></span><br><span class="line"><span class="class">// <span class="title">List</span>&lt;<span class="title">T</span>&gt; 对应<span class="title">R</span></span></span><br></pre></td></tr></table></figure>
<p>下面我们来看Collector接口中每个方法的作用。</p>
<dl>
<dt>Supplier&lt;A&gt; supplier()</dt>
<dd>在调用时它会创建一个空的累加器实例，供数据收集过程使用。</dd>
</dl>
<p>在我们的ToListCollector中， supplier返回一个空的List，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">	<span class="keyword">return</span> () -&gt; <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以只传递一个构造函数引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">	<span class="keyword">return</span> ArrayList::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<dl>
<dt>BiConsumer&lt;A, T&gt; accumulator();</dt>
<dd>accumulator方法会返回执行归约操作的函数。当遍历到流中第n个元素时，这个函数执行时会有两个参数：保存归约结果的累加器（已收集了流中的前 n - 1 个项目）， 还有第n个元素本身。</dd>
</dl>
<p>对于ToListCollector而言：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">	<span class="keyword">return</span> List::add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<dl>
<dt>Function&lt;A, R&gt; finisher();</dt>
<dd>方法返回在累积过程的最后要调用的一个函数，该函数将累加器对象转换为整个集合操作的最终结果</dd>
</dl>
<p>通常，就像ToListCollector的情况一样，累加器对象恰好符合预期的最终结果，因此无需进行转换。所以finisher方法只需返回identity函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">	<span class="keyword">return</span> Function.identity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于顺序流的处理过程，理解supplier、accumulator和finisher三个函数就够了：</p>
<p><img src="/2019/06/03/Java8-之-Stream/%E9%A1%BA%E5%BA%8F%E5%BD%92%E7%BA%A6%E8%BF%87%E7%A8%8B%E7%9A%84%E9%80%BB%E8%BE%91%E6%AD%A5%E9%AA%A4.PNG" alt="顺序归约过程的逻辑步骤"></p>
<p>对于并行流而言，由于会将流分割成几个子任务并发收集，所以同时会存在多个收集重启，所以最终需要使用combiner函数将这些部分结果容器合并成一个最终的结果容器。</p>
<dl>
<dt>BinaryOperator&lt;A&gt; combiner();</dt>
<dd>方法会返回一个供归约操作使用的函数，它定义了对流的各个子部分进行并行处理时，各个子部分归约所得的累加器要如何合并。</dd>
</dl>
<p>对于toList而言，这个方法的实现非常简单，只要把从流的第二个部分收集到的项目列表加到遍历第一部分时得到
的列表后面就行了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">    <span class="keyword">return</span> (list1, list2) -&gt; </span><br><span class="line">    			&#123;list1.addAll(list2);<span class="keyword">return</span> list1; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/03/Java8-之-Stream/%E4%BD%BF%E7%94%A8combiner%E6%96%B9%E6%B3%95%E6%9D%A5%E5%B9%B6%E8%A1%8C%E5%8C%96%E5%BD%92%E7%BA%A6%E8%BF%87%E7%A8%8B.PNG" alt="使用combiner方法来并行化归约过程"></p>
<p>Set&lt;Characteristics&gt; characteristics()</p>
<p>： 会返回一个不可变的Characteristics集合，提供了一系列特征，也就是一个提示列表，告诉collect方法在执行归约操作的时候可以应用哪些优化（比如并行化）。</p>
<p>Characteristics是一个包含三个项目的枚举：</p>
<ul>
<li>UNORDERED——收集后的顺序可不保持流中元素的“遭遇顺序”(encounter-order)</li>
<li>CONCURRENT——accumulator函数可以从多个线程同时调用，即收集容器是线程安全的，如果收集器是CONCURRENT，则Supplier只会被调用一次，即自始至终只会创建一个收集容器。如果收集器没有标为UNORDERED，那它仅在用于无序数据源时才可以并发收集。（如果为UNORDERED，则对于有序/无序源都进行并发收集）</li>
<li>IDENTITY_FINISH——这表明完成器方法返回的函数是一个恒等函数，可以跳过。这种情况下，累加器对象将会直接用作归约过程的最终结果。这也意味着，将累加器A不加检查地转换为结果R是安全的。</li>
</ul>
<blockquote>
<p>我们迄今开发的ToListCollector是IDENTITY_FINISH的，因为用来累积流中元素的 List已经是我们要的最终结果，用不着进一步转换了，但它并不是UNORDERED，因为用在有序流上的时候，我们还是希望顺序能够保留在得到的List中。最后，它是CONCURRENT的，但我们刚才说过了，仅仅在背后的数据源无序时才会并行处理。</p>
</blockquote>
<p><strong>笔者注：《Java8实战》中以上论述有误，ToListCollector不能是<code>CONCURRENT</code>的，因为采用的收集容器ArrayList是非线程安全的，经过我的测试，并行流收集时会发生问题。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToListCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">List</span>&lt;<span class="title">T</span>&gt;, <span class="title">List</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;List&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        <span class="keyword">return</span> ArrayList::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;List&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        <span class="keyword">return</span> List::add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;List&lt;T&gt;, List&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line">        <span class="keyword">return</span> Function.identity();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;List&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        <span class="keyword">return</span> (list1, list2) -&gt; &#123;</span><br><span class="line">            list1.addAll(list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(</span><br><span class="line">                IDENTITY_FINISH, CONCURRENT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用自定义的收集器。</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = IntStream.range(<span class="number">1</span>, <span class="number">1000</span>).mapToObj(Integer::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Integer&gt; collect = integerStream.parallel().collect(<span class="keyword">new</span> ToListCollector&lt;&gt;());</span><br></pre></td></tr></table></figure>
<h1 id="并行流">并行流</h1>
<p>关于并行流，希望大家还是多看写书和文档，笔者目前也没有理解透彻。。。</p>
<p>总之，就是在使用并行流时要谨慎。往往你对并行流的理解并不是对的。比如如下两个例子的输出结果，大多数人的判断都是错的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)；</span><br><span class="line"></span><br><span class="line">integerStream.parallel().forEach(System.out::println);</span><br><span class="line">integerStream.parallel().collect(toList()).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p>如果你感到很奇怪，可以参考我的博客文章<a href="https://blog.csdn.net/u012364631/article/details/89020335" target="_blank" rel="noopener">Java8 ParallelStream并行流不一定返回乱序结果</a>。</p>
<p>不过如果不依赖于顺序性时，一般都可放心大胆使用。</p>
<p>但是<strong>并不是使用了并行流后效率就一定高</strong>：要考虑到并行化的额外开销。<u>对于较小的数据量，选择并行流几乎从来都不是一个好的决定</u> 。</p>
<p>另外<strong>在这些的情景下，不要使用并行流</strong>，原因可以参考《Java8实战》关于并行流的部分：</p>
<ul>
<li>收集容器是LinkedList时，不要使用并行流</li>
<li>流是从Stream.iterate()生成时，不要使用并行流</li>
<li>findFirst等依赖于元素顺序的操作，不要使用并行流</li>
</ul>
<h1 id="注意">注意</h1>
<h2 id="流只能遍历一次">流只能遍历一次</h2>
<p>遍历完之后，我们就说这个流已经被消费掉了。可以从原始数据源那里再获得一个新的流来重新遍历一遍（如果数据源是可重放的话，比如集合），但不能对同一个流遍历两遍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如，以下代码会抛出一个异常</span></span><br><span class="line">List&lt;String&gt; title = Arrays.asList(<span class="string">"Java8"</span>, <span class="string">"In"</span>, <span class="string">"Action"</span>);</span><br><span class="line">Stream&lt;String&gt; s = title.stream();</span><br><span class="line">s.forEach(System.out::println);</span><br><span class="line">s.forEach(System.out::println);<span class="comment">// java.lang.IllegalStateException:流已被操作或关闭</span></span><br></pre></td></tr></table></figure>
<h2 id="流与集合的区别">流与集合的区别</h2>
<blockquote>
<ul>
<li>比如说存在DVD里的电影，DVD就是一个集合，因为它包含了所有的数据。</li>
<li>现在再来想想在网上通过视频流看电影。流媒体视频播放器只要下载用户观看位置的那几帧就可以了，这样不用等到流中大部分值计算出来，你就可以边下载边播放流（比如观看直播足球赛）。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>粗略地说，<u>集合与流之间的差异就在于什么时候进行计算</u>。集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中。（你可以往集合里加东西或者删东西，但是不管什么时候，集合中的每个元素都是放在内存里的，元素都得先算出来才能成为集合的一部分。）</li>
<li>相比之下，流则是在概念上固定的数据结构（你不能添加或删除元素），其元素则是按需计算的 。流就
像是一个延迟创建的集合：只有在消费者要求的时候才会计算值 。</li>
</ul>
</blockquote>
<p>收集器与规约的关系</p>
<h1 id="总结">总结</h1>
<p>总结一下， Java 8中的Stream API可以让你写出这样的代码：</p>
<ul>
<li>声明性——更简洁，更易读</li>
<li>可复合——更灵活</li>
<li>可并行——性能更好</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>UNO，UNC</th>
<th>UNO，C</th>
<th>O，UNC</th>
<th>O，C</th>
</tr>
</thead>
<tbody>
<tr>
<td>unP,unO</td>
<td>sup：1，com：0，有序</td>
<td>sup：1，com：0，有序</td>
<td>sup：1，com：0，有序</td>
<td>sup：1，com：0，有序</td>
</tr>
<tr>
<td>unP,O</td>
<td>sup：1，com：0，有序</td>
<td>sup：1，com：0，有序</td>
<td>sup：1，com：0，有序</td>
<td>sup：1，com：0，有序</td>
</tr>
<tr>
<td>P,unO</td>
<td>sup：n，com：m，有序(并行计算、并行收集)</td>
<td>sup：1，com：0，无序（并行计算、并发收集）</td>
<td>sup：n，com：m,有序(并行计算、并行收集)</td>
<td>sup：1，com：0，无序（并行计算、并发收集）</td>
</tr>
<tr>
<td>P,O</td>
<td>sup：n，com：m，有序(并行计算、并行收集)</td>
<td>sup：1，com：0，无序（并行计算、并发收集）</td>
<td>sup：n，com：m,有序(并行计算、并行收集)</td>
<td>sup：n，com：m,有序  (如果Collect是有序的，仅当源为无序时，才并发收集)。此处为并行计算、并行收集。但是收集器会保证收集顺序保持为遭遇顺序。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>If the stream is sequential, it will be sequential.</p>
<p>If the stream is parallel, it will be a parallel or concurrent <strong>collect</strong>. If at least either, the stream or the collector, is unordered and the collector has the <code>CONCURRENT</code> characteristic. it will be concurrent, otherwise it will be parallel.</p>
<p><a href="https://stackoverflow.com/questions/50625544/confusion-about-characteristics-unordered-in-java-8-in-action-book" target="_blank" rel="noopener">https://stackoverflow.com/questions/50625544/confusion-about-characteristics-unordered-in-java-8-in-action-book</a></p>
</blockquote>

    
    </div>
    
    
        <div class="article-comment" id="article-comment">
            

<h1>Comment</h1>

  
    <div id="valine"></div>
  


        </div>
        
</article>
  </div>

  

<footer id="footer">
    <div class="footer-copyright">
        <div>
            <p> Copyright by <a href>Li JunFeng </a> @ 2019</p>
            <p>Designed by: <i class="fas fa-paint-brush"></i> <a href="https://moober.cn">Moober</a> and <i class="fas fa-graduation-cap"></i> <a href="https://qutang.github.io">Qu Tang</a> &bull; Theme: <a href="https://qutang.github.io/cutie/">Cutie 2.1.3-Taurus</a> &bull; Powered by <a href="http://hexo.io">Hexo.</a></p>
        </div>
    </div>
    
    <div class="footer-social">
        
            
                
                    <div class="footer-social-item"><a href="https://github.com/lijunfeng722" target="_blank"><i class="fab fa-github fa-2x" aria-hidden="true"></i></a></div>
                
            
        
    </div>
</footer>

  <br>

  <div id="footer-nav" class='footer-nav'>
		



<nav id="nav">
	
	
	
	<div class="nav-item" id="nav-item-toc">
		


<div class="toc-container">
<i class="far fa-times-circle" id="toc-close" onclick="closeTOC(event);" ontouchstart="closeTOC(event);"></i>
<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引言"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#流操作"><span class="toc-number">2.</span> <span class="toc-text">流操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#中间操作"><span class="toc-number">2.1.</span> <span class="toc-text">中间操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终端操作"><span class="toc-number">2.2.</span> <span class="toc-text">终端操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用流"><span class="toc-number">2.3.</span> <span class="toc-text">使用流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用流-v2"><span class="toc-number">3.</span> <span class="toc-text">使用流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#筛选"><span class="toc-number">3.1.</span> <span class="toc-text">筛选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#查找元素"><span class="toc-number">3.2.</span> <span class="toc-text">查找元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归约"><span class="toc-number">3.3.</span> <span class="toc-text">归约</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数值流"><span class="toc-number">3.4.</span> <span class="toc-text">数值流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建流"><span class="toc-number">3.5.</span> <span class="toc-text">构建流</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#收集器"><span class="toc-number">4.</span> <span class="toc-text">收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#收集器简介"><span class="toc-number">4.1.</span> <span class="toc-text">收集器简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#预定义收集器"><span class="toc-number">4.2.</span> <span class="toc-text">预定义收集器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义收集器"><span class="toc-number">4.3.</span> <span class="toc-text">自定义收集器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#并行流"><span class="toc-number">5.</span> <span class="toc-text">并行流</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#注意"><span class="toc-number">6.</span> <span class="toc-text">注意</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#流只能遍历一次"><span class="toc-number">6.1.</span> <span class="toc-text">流只能遍历一次</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流与集合的区别"><span class="toc-number">6.2.</span> <span class="toc-text">流与集合的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol>
</div>
<div class="toc-button" onclick="toggleTOC(event);" ontouchstart="toggleTOC(event);">
    <img src="/images/icons/colorful-outlined/toc.svg" alt>
</div>

	</div>
	
	<div class="nav-item" id="nav-item-archive">
		
				<div class="nav-icon">
				
			<a href="/archives/" title="Archives">
			<img src="/images/icons/colorful-outlined/archive.svg" alt>
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-search">
		
		<div class="nav-icon">
		
			<a href="/search/" title="Search">
			<img src="/images/icons/colorful-outlined/search.svg" alt>
			</a>
		</div>
	</div>
	<div class="nav-item" id="nav-item-more">
		<div class="nav-icon">
				<a href="#" onclick="onClickMenuIcon(event);" ontouchstart="onClickMenuIcon(event);">
				<img src="/images/icons/colorful-outlined/menu.svg" alt>
				</a>
		</div>
		<div class="nav-more-menu">
				<i class="far fa-times-circle" id="nav-more-menu-close" onclick="onClickNavMenuClose(event);" ontouchstart="onClickNavMenuClose(event);"></i>
		
		
		<div class="nav-more-item">
				<div class="nav-name">
					<a class="nav-link" href="/categories/Java/">
						<span>Java</span>
					</a>
				</div>
		</div>
		
	</div>
	</div>
</nav>

	</div>

  



    
    
    
    
<script>
    new Valine({
        el: '#valine',
        notify:false, 
        verify:false,
        appId: 'V0jTkst5qpMeK7oHyQYwLB85-gzGzoHsz',
        appKey: 'rWMxYnrvsMGqWwJFbczwXkPY',
        placeholder: 'write your comment',
        path:window.location.pathname, 
        avatar:'retro',
        lang: 'en'
    });
</script>













<script type="text/javascript">

  
  // update cookie if this page is opened (directly)
  loadjs(['/libs/jshashes/hashes.min.js', '/libs/js-cookie/src/js.cookie.js', '/js/post.v2.js'], 'post-version');
  loadjs.ready('post-version', function(){
    
    new Postv2('hashit_980a0dfb26d29a780642e110939b854feb221f67491e5004ba8ba96c5e9daea0').update('hashit_077991da620d8091551b4b338e69f99d036915f01fb3c232f3e8ba4fc0228d7a', function(){});
  });
  
</script>


    
<script type="text/javascript">
  
  // update cookie if this page is opened (directly)
  function getIP(json) {
  loadjs(['/libs/jshashes/hashes.min.js', '/libs/js-cookie/src/js.cookie.js', '/js/leancloud.js'], 'post-visit-comment-count');
  loadjs.ready('post-visit-comment-count', function(){
    
    
    LeanCloud.init('V0jTkst5qpMeK7oHyQYwLB85-gzGzoHsz', 'rWMxYnrvsMGqWwJFbczwXkPY');
    var leanCloud = LeanCloud.getInstance();
    leanCloud.fetchIsThumbUp('/2019/06/03/Java8-之-Stream/', json.ip);
    document.getElementById('thumb-up-button').addEventListener('click', function(e){
      leanCloud.isThumbUp('/2019/06/03/Java8-之-Stream/', function(isThumbUp){
        console.log('is thumb up:' + isThumbUp);
        if(isThumbUp){
          leanCloud.removeThumbUpRecord('/2019/06/03/Java8-之-Stream/', json.ip);
          document.getElementById('thumb-up-icon').className = "far fa-thumbs-up fa-lg";
          
        }else{
          leanCloud.addThumbUpRecord('/2019/06/03/Java8-之-Stream/', json.ip);
          document.getElementById('thumb-up-icon').className = "fas fa-thumbs-up fa-lg";
        }
        leanCloud.getThumbUpCount('/2019/06/03/Java8-之-Stream/', function(count){
            console.log('thumb up count: ' + count)
            var el = document.getElementById('article-thumbup-count');
            if(el) el.innerHTML = count;
        });
      });
    });
    leanCloud.addVisitRecord('/2019/06/03/Java8-之-Stream/', json.ip);
    leanCloud.fetchCommentCount('/2019/06/03/Java8-之-Stream/');
    leanCloud.fetchVisitCount('/2019/06/03/Java8-之-Stream/');
    leanCloud.fetchThumbUpCount('/2019/06/03/Java8-之-Stream/');
    leanCloud.getCommentCount('/2019/06/03/Java8-之-Stream/', function(count){
        var el = document.querySelector('#article-comment-count');
        if(el) el.innerHTML = count;
    });
    leanCloud.getVisitCount('/2019/06/03/Java8-之-Stream/', function(count){
        var el = document.querySelector('#article-visit-count');
        if(el) el.innerHTML = count;
    });
    leanCloud.getThumbUpCount('/2019/06/03/Java8-之-Stream/', function(count){
        var el = document.getElementById('article-thumbup-count');
        if(el) el.innerHTML = count;
    });
    leanCloud.isThumbUp('/2019/06/03/Java8-之-Stream/', function(isThumbUp){
        console.log('init thumb up:' + isThumbUp);
        if(isThumbUp){
          document.getElementById('thumb-up-icon').className = "fas fa-thumbs-up fa-lg";
        }else{
          document.getElementById('thumb-up-icon').className = "far fa-thumbs-up fa-lg";
        }
    });
  });
  }
  
</script>

<script type="application/javascript" src="https://api.ipify.org?format=jsonp&callback=getIP"></script>



<!-- <script src="/js/post.js"></script> -->

<script src="/js/headroom.min.js"></script>

<script data-no-instant type="text/javascript">

initHeadroom();

changeLayoutOnTouchScreen();

// 
// var post = new Post('V0jTkst5qpMeK7oHyQYwLB85-gzGzoHsz', 'rWMxYnrvsMGqWwJFbczwXkPY');
// post.getCommentCount(window.location.pathname, function(count){
//     $('#article-comment-count').text(count);
// });
// post.addVisitRecord(window.location.pathname, userip);
// post.getVisitCount(window.location.pathname, function(count){
//     $('#article-visit-count').text(count);
// });

// 
</script>


<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
